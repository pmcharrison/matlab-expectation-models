function [leman, collins, collins_detail] = analyse_sequence(...
    wav_file, ...
    wav_dir, ...
    onsets, ...
    offsets, ...
    use_closure, ...
    leman_2000_local_decay_sec, ... % typically 0.1; may be vectorised
    leman_2000_global_decay_sec, ... % typically 1.5; may be vectorised
    jlmtpath, ...
    do_collins)

assert(isequal(size(onsets, 1), 1));

assert(isequal(size(leman_2000_local_decay_sec, 1), 1));
assert(isequal(...
    size(leman_2000_local_decay_sec, 1), ...
    size(leman_2000_global_decay_sec, 1)));

M = size(leman_2000_local_decay_sec, 2);
N = size(onsets, 2);

% Returns a M x N array
% where M indexes the different Leman (2000) decay constant pairs
% and N indexes the N onsets/offsets
leman = NaN(M, N);
for i = 1:M
    leman(i, :) = leman_2000(...
        wav_file, ...
        wav_dir, ...
        onsets, offsets, ...
        leman_2000_local_decay_sec(i), ...
        leman_2000_global_decay_sec(i));
end

if use_closure
    % Closure is modelled for the last element in the sequence
    use_closures = [false(1, N - 1), true];
else
    % Closure is disabled for all elements in the sequence
    use_closures = false(1, N);
end

collins = NaN;
collins_detail = NaN;

if do_collins
    [collins, collins_detail] = arrayfun(...
        @(onset, use_closure) collins_2014(...
        wav_file, ...
        wav_dir, ...
        onset, ...
        use_closure, ...
        jlmtpath), onsets, use_closures);
end
end